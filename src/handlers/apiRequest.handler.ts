import http from 'http';
import https, { RequestOptions } from 'https';
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { processAuthenticationHeader } from '../utils/authentication.util';

export class ApiRequestHandler {
    private spec: any;

    constructor(spec: any) {
        this.spec = spec;
    }

    private buildPath(testPath: string, queryParams?: Array<{ name: string, value: string }>): string {
        const server: string = this.spec.servers[0].url.replace("https://", "");
        const urlPart: string[] = server.split("/");
        const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

        let path = suffix ? `/${suffix}${testPath}` : testPath;

        if (queryParams && queryParams.length > 0) {
            const query = queryParams
                .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
                .join("&");
            path += `?${query}`;
        }

        return path;
    }

    private buildHeaders(testHeaders?: Array<{ name: string, value: string }>): Record<string, string> {
        return testHeaders
            ? testHeaders.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {})
            : {};
    }

    async buildOptions(test: TestCaseType, testFileSettings: TestFileType): Promise<RequestOptions> {
        const path = this.buildPath(test.path, test.params.query);
        const headers = this.buildHeaders(test.headers);

        const requestOptions: RequestOptions = {
            host: this.spec.servers[0].url.replace("https://", "").split("/")[0],
            port: 443,
            path,
            method: test.method,
            headers
        };

        const authentication = test.authentication || testFileSettings.authentication;
        const authHeader = await processAuthenticationHeader(authentication);

        return {
            ...requestOptions,
            headers: { ...headers, ...authHeader }
        };
    }

    async sendRequest(options: RequestOptions, body?: string): Promise<{ data: http.IncomingMessage, body: string }> {
        return new Promise((resolve, reject) => {
            const req = https.request(options, (res) => {
                let responseBody = "";
                res.on('data', chunk => responseBody += chunk);
                res.on("end", () => resolve({ data: res, body: responseBody }));
                res.on("error", reject);
            });

            req.on('error', reject);

            if (['POST', 'PUT', 'PATCH'].includes(options.method || '') && body) {
                req.write(body);
            }

            req.end();
        });
    }
}