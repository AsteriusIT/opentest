import chalk from "chalk";
import fs from "fs";
import { TestCaseType } from '../types/testCase.type';
import { RequestOptions } from 'https';

interface ILogger {
    logTest(test: TestCaseType, body: string | undefined, options: RequestOptions): void;
    logStatusCodeResult(expected: number, received: number | undefined): void;
    logBodyResult(expected: any, received: string, schema?: any): void;
    logBodyResultSuccess(schema: boolean): void;
    saveResponses(output: string, responses: { passed: boolean, errors: any[], data: TestCaseType }[]): void;
}

class ConsoleLogger implements ILogger {
    logTest(test: TestCaseType, body: string | undefined, options: RequestOptions): void {
        console.log(chalk.bgBlue.white(' ➤ Test Details '));
        console.log(`${chalk.blueBright('🔍')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
        console.log(`${chalk.blueBright('📝')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
        console.log(`${chalk.blueBright('🔗')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
        console.log(`${chalk.blueBright('🚀')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
        console.log(`${chalk.blueBright('🔧')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
        if (body) {
            console.log(`${chalk.blueBright('🧙‍♂️')} ${chalk.bold('Body:')} ${chalk.yellow(body)}`);
        }

        const requestHeaders = { ...options.headers };
        if (test.headers) {
            test.headers.forEach(h => delete requestHeaders[h.name]);
        }

        if (test.headers) {
            console.log(`${chalk.blueBright('👨')} ${chalk.bold('Headers:')} ${chalk.yellow(JSON.stringify(test.headers, null, 2))}`);
        }
        if (requestHeaders) {
            const maskedHeaders = { ...requestHeaders };
            if (maskedHeaders.Authorization) {
                maskedHeaders.Authorization = 'Bearer ********';
            }
            console.log(`${chalk.blueBright('👮‍♂️')} ${chalk.bold('Request Headers:')} ${chalk.yellow(JSON.stringify(maskedHeaders, null, 2))}`);
        }
        console.log(`${chalk.blueBright('✅')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
    }

    logStatusCodeResult(expected: number, received: number | undefined): void {
        if (received !== expected) {
            console.error(chalk.bgRed.white(' ❌ Error: Status Code Mismatch'));
            console.error(`${chalk.red('🚫 Expected Status Code:')} ${chalk.yellow(expected)}`);
            console.error(`${chalk.red('🛑 Received Status Code:')} ${chalk.yellow(received)}`);
        } else {
            console.log(chalk.bgGreen.black(' ✅ Success: Status Code Match'));
            console.log(`${chalk.green('✔️ Status Code:')} ${chalk.white(received)}`);
        }
    }

    logBodyResult(expected: any, received: string, schema?: any): void {
        if (schema) {
            console.error(chalk.bgRed.white(' ❌ Error: Response Body does not match schema'));
            console.error(`${chalk.red('🚫 Expected Response Body schema:')} ${chalk.yellow(JSON.stringify(schema))}`);
            console.error(`${chalk.red('🛑 Received Response Body:')} ${chalk.yellow(received)}`);
        } else if (JSON.stringify(expected) !== JSON.stringify(JSON.parse(received))) {
            console.error(chalk.bgRed.white(' ❌ Error: Response Body Mismatch'));
            console.error(`${chalk.red('🚫 Expected Response Body:')} ${chalk.yellow(JSON.stringify(expected))}`);
            console.error(`${chalk.red('🛑 Received Response Body:')} ${chalk.yellow(received)}`);
        } else {
            console.log(chalk.bgGreen.black(' ✅ Success: Response Body Match'));
        }
    }

    logBodyResultSuccess(schema: boolean): void {
        if (schema) {
            console.log(chalk.bgGreen.black(' ✅ Success: Response Body Match Schema'));
        } else {
            console.log(chalk.bgGreen.black(' ✅ Success: Response Body Match'));
        }
    }

    saveResponses(output: string, responses: { passed: boolean, errors: any[], data: TestCaseType }[]): void {
        const data = responses.map(response => ({
            name: response.data.name,
            description: response.data.description,
            errors: response.errors
        }));

        const json = JSON.stringify(data, null, 2);
        fs.writeFileSync(output, json);
        console.log(chalk.green(`Results saved to ${output}`));
    }
}

class JsonLogger implements ILogger {
    logBodyResultSuccess(): void {
        throw new Error("Method not implemented.");
    }
    private logs: any[] = [];

    logTest(test: TestCaseType, body: string | undefined, options: RequestOptions): void {
        this.logs.push({
            type: 'test_details',
            test: test,
            body: body,
            options: options
        });
    }

    logStatusCodeResult(expected: number, received: number | undefined): void {
        this.logs.push({
            type: 'status_code_result',
            expected: expected,
            received: received,
            passed: expected === received
        });
    }

    logBodyResult(expected: any, received: string, schema?: any): void {
        this.logs.push({
            type: 'body_result',
            expected: expected,
            received: JSON.parse(received),
            schema: schema,
            passed: schema ? true : JSON.stringify(expected) === JSON.stringify(JSON.parse(received))
        });
    }

    saveResponses(output: string, responses: { passed: boolean, errors: any[], data: TestCaseType }[]): void {
        const allLogs = {
            testResults: responses,
            logs: this.logs
        };
        fs.writeFileSync(output, JSON.stringify(allLogs, null, 2));
    }
}

export { ILogger, ConsoleLogger, JsonLogger };