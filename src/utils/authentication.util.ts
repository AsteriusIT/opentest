import https, { RequestOptions } from 'https';
import { AuthenticationOauth2Type } from "../types/authentication.type";

interface IAuthStrategy {
    getAuthorizationHeader(): Promise<string>;
}

class BearerAuthStrategy implements IAuthStrategy {
    private token: string;

    constructor(token: string) {
        this.token = token;
    }

    async getAuthorizationHeader(): Promise<string> {
        return `Bearer ${this.token}`;
    }
}

class OAuth2AuthStrategy implements IAuthStrategy {
    private authConfig: AuthenticationOauth2Type;

    constructor(authConfig: AuthenticationOauth2Type) {
        this.authConfig = authConfig;
    }

    async getAuthorizationHeader(): Promise<string> {
        const token = await this.getAccessToken();
        return `Bearer ${token}`;
    }

    private getAccessToken(): Promise<string> {
        return new Promise((resolve, reject) => {
            const parsedUrl = new URL(this.authConfig.accessTokenUrl);
            const options: RequestOptions = {
                host: parsedUrl.host,
                port: 443,
                path: parsedUrl.pathname,
                method: 'POST',
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                }
            }
            const req = https.request(options, (res) => {
                let responseBody: string = "";

                res.on('data', (responseBodyData) => responseBody += responseBodyData);
                res.on("end", () => resolve(JSON.parse(responseBody).access_token));
                res.on("error", (error) => reject(error));
            });

            if (!this.authConfig.clientId || !this.authConfig.clientSecret || !this.authConfig.grantType || !this.authConfig.scope) {
                throw new Error('Invalid OAuth2 configuration');
            }

            req.write(new URLSearchParams({
                'client_id': this.authConfig.clientId,
                'client_secret': this.authConfig.clientSecret,
                'grant_type': this.authConfig.grantType,
                'scope': this.authConfig.scope
            }).toString())

            req.end();
        });
    }
}

function createAuthStrategy(authentication: { type: string, value: any }): IAuthStrategy {
    switch (authentication.type) {
        case 'bearer':
            return new BearerAuthStrategy(authentication.value.raw);
        case 'oauth2':
            return new OAuth2AuthStrategy(authentication.value);
        default:
            throw new Error(`Unsupported authentication type: ${authentication.type}`);
    }
}

async function processAuthenticationHeader(authentication: { type: string, value: any } | undefined): Promise<Record<string, string>> {
    if (!authentication) {
        return {};
    }

    const authStrategy = createAuthStrategy(authentication);
    const authorizationHeader = await authStrategy.getAuthorizationHeader();
    return { Authorization: authorizationHeader };
}

export { BearerAuthStrategy, createAuthStrategy, IAuthStrategy, OAuth2AuthStrategy, processAuthenticationHeader };

