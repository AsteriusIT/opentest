import Ajv from "ajv";
import addFormats from 'ajv-formats';
import addMetaSchema2020 from 'ajv/dist/refs/json-schema-2020-12';
import Ajv2020 from 'ajv/dist/2020';
import { ErrorObject } from "ajv/dist/types";
import { OpenAPIV3 } from "openapi-types";
import schemaFile from "../../schemas/test.opentest-schema.json";
import { TestFileType } from "../types/testFile.type";


/**
 * Validate a TestFileType against opentest schema
 * @param file
 */
export function validateSchema(file: TestFileType): { success: boolean, errors?: null | ErrorObject[] } {
    const ajv = new Ajv2020({ allErrors: true, strict: false });
    addFormats(ajv);

    const schema = schemaFile;
    const validate = ajv.compile(schema);

    try {
        const valid: boolean = validate(file)
        return {
            success: valid,
            errors: validate.errors
        };
    } catch (error) {
        console.error(error);
        return {
            success: false,
            errors: validate.errors
        };
    }
}

// Load and compile schemas
function addSchemasToAjv(ajv: Ajv, schemas: Record<string, any>) {
    Object.entries(schemas).forEach(([key, schema]) => {
        ajv.addSchema(schema, key);
    });
}

// Validate JSON data against a specific schema
function validateJson(ajv: Ajv, schemaName: string, jsonData: any): { success: boolean, errors?: null | ErrorObject[] } {
    const validate = ajv.getSchema(schemaName);
    if (!validate) {
        console.error(`Schema ${schemaName} not found.`);
        return;
    }
    const valid = validate(jsonData);
    if (!valid) {
        console.log('Validation errors:', validate.errors);
        return {
            success: false,
            errors: validate.errors
        };
    } else {
        console.log('Validation successful!');
    }

    return { success: true };
}

function resolveRefs(obj: any, spec: any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => resolveRefs(item, spec));
    } else if (obj !== null && typeof obj === 'object') {
        if (obj.hasOwnProperty('$ref')) {
            const refPath = obj['$ref'].replace(/^#\//, '').split('/');
            let refObj = spec;
            for (const part of refPath) {
                refObj = refObj[part];
            }
            return resolveRefs(refObj, spec); // Recursively resolve nested refs
        }
        const newObj: any = {};
        for (const [key, value] of Object.entries(obj)) {
            newObj[key] = resolveRefs(value, spec);
        }
        return newObj;
    }
    return obj;
}

function extractAndResolveSchemas(spec: OpenAPIV3.Document): Record<string, any> {
    const schemas = spec.components?.schemas ?? {};
    const resolvedSchemas: any = {};
    for (const [key, schema] of Object.entries(schemas)) {
        resolvedSchemas[key] = resolveRefs(schema, spec);
        resolvedSchemas[key]["additionalProperties"] = false;
    }
    return resolvedSchemas;
}


export function validateSchema2(spec: OpenAPIV3.Document, schema: any, response: any): { success: boolean, errors?: null | ErrorObject[] } {
    const ajv = new Ajv({ allErrors: true, strict: false });
    const resolvedSchemas = extractAndResolveSchemas(spec);
    addSchemasToAjv(ajv, resolvedSchemas);

    return validateJson(ajv, schema, response);
}

export function getSchemaFromOpenApi(spec: OpenAPIV3.Document, schemaName: string): any {
    const schemas = spec.components?.schemas ?? {};
    const schema = schemas[schemaName];
    if (!schema) {
        console.error(`Schema ${schemaName} not found.`);
        return;
    }
    return schema;
}