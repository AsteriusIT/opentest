import Ajv from "ajv";
import Ajv2020 from 'ajv/dist/2020';
import { ErrorObject } from "ajv/dist/types";
import { OpenAPIV3 } from "openapi-types";
import schemaFile from "../../schemas/test.opentest-schema.json";
import { TestFileType } from "../types/testFile.type";


/**
 * Validate a TestFileType against opentest schema
 * @param file
 */
export function validateOpentestSchema(file: TestFileType): { success: boolean, errors?: null | ErrorObject[] } {
    const ajv: Ajv2020 = new Ajv2020({ allErrors: true, strict: false });
    const schema = schemaFile;
    const validate = ajv.compile(schema);

    try {
        const valid: boolean = validate(file)
        return {
            success: valid,
            errors: validate.errors
        };
    } catch (error) {
        console.error(error);
        return {
            success: false,
            errors: validate.errors
        };
    }
}

export class SchemaValidator {
    private ajv: Ajv2020;
    private spec: OpenAPIV3.Document;

    constructor(spec: OpenAPIV3.Document) {
        this.ajv = new Ajv2020({ allErrors: true, strict: false });
        this.spec = spec;
        this.initializeSchemas();
    }

    private initializeSchemas(): void {
        const resolvedSchemas = this.extractAndResolveSchemas();
        Object.entries(resolvedSchemas).forEach(([key, schema]) => {
            this.ajv.addSchema(schema, key);
        });
    }

    public validateJson(schemaName: string, jsonData: any): { success: boolean, errors?: null | ErrorObject[] } {
        const validate = this.ajv.getSchema(schemaName);

        if (!validate) throw new Error(`Schema ${schemaName} not found.`);

        const valid = validate(jsonData);
        if (!valid) {
            return {
                success: false,
                errors: validate.errors
            };
        }

        return { success: true };
    }

    private resolveRefs(obj: any): any {
        if (Array.isArray(obj)) {
            return obj.map(item => this.resolveRefs(item));
        } else if (obj !== null && typeof obj === 'object') {
            if (obj.hasOwnProperty('$ref')) {
                const refPath = obj['$ref'].replace(/^#\//, '').split('/');
                let refObj = this.spec;
                for (const part of refPath) {
                    refObj = refObj[part];
                }
                return this.resolveRefs(refObj);
            }
            const newObj: any = {};
            for (const [key, value] of Object.entries(obj)) {
                newObj[key] = this.resolveRefs(value);
            }
            return newObj;
        }
        return obj;
    }

    private extractAndResolveSchemas(): Record<string, any> {
        const schemas = this.spec.components?.schemas ?? {};
        const resolvedSchemas: any = {};
        for (const [key, schema] of Object.entries(schemas)) {
            resolvedSchemas[key] = this.resolveRefs(schema);
            resolvedSchemas[key]["additionalProperties"] = false;
        }
        return resolvedSchemas;
    }

    public getSchemaFromOpenApi(schemaName: string): any {
        const schemas = this.spec.components?.schemas ?? {};
        const schema = schemas[schemaName];
        if (!schema) {
            throw new Error(`Schema ${schemaName} not found.`);
        }
        return schema;
    }
}

export function createSchemaValidator(spec: OpenAPIV3.Document): SchemaValidator {
    return new SchemaValidator(spec);
}
