import Ajv from "ajv";
import chalk from "chalk";
import https, { RequestOptions } from 'https';
import http from "node:http";
import { OpenAPIV3 } from 'openapi-types';
import { AuthenticationBearerType, AuthenticationOauth2Type } from "../types/authentication.type";
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { getOpenApiFile, getOpenApiTestFile } from '../utils/files.util';
import { validateCommandFunc } from "./validate.command";

function extractSchemas(spec: OpenAPIV3.Document): OpenAPIV3.SchemaObject {
    return spec.components?.schemas ?? {};
}

const ajv = new Ajv({ allErrors: true, strict: false });

// Load and compile schemas
function addSchemasToAjv(ajv: Ajv, schemas: Record<string, any>) {
    Object.entries(schemas).forEach(([key, schema]) => {
        ajv.addSchema(schema, key);
    });
}


// Validate JSON data against a specific schema
function validateJson(schemaName: string, jsonData: any) {
    const validate = ajv.getSchema(schemaName);
    if (!validate) {
        console.error(`Schema ${schemaName} not found.`);
        return;
    }
    const valid = validate(jsonData);
    if (!valid) {
        console.log('Validation errors:', validate.errors);
    } else {
        console.log('Validation successful!');
    }

    return valid;
}

function resolveRefs(obj: any, spec: any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => resolveRefs(item, spec));
    } else if (obj !== null && typeof obj === 'object') {
        if (obj.hasOwnProperty('$ref')) {
            const refPath = obj['$ref'].replace(/^#\//, '').split('/');
            let refObj = spec;
            for (const part of refPath) {
                refObj = refObj[part];
            }
            return resolveRefs(refObj, spec); // Recursively resolve nested refs
        }
        const newObj: any = {};
        for (const [key, value] of Object.entries(obj)) {
            newObj[key] = resolveRefs(value, spec);
        }
        return newObj;
    }
    return obj;
}

function extractAndResolveSchemas(spec: OpenAPIV3.Document): Record<string, any> {
    const schemas = spec.components?.schemas ?? {};
    const resolvedSchemas: any = {};
    for (const [key, schema] of Object.entries(schemas)) {
        resolvedSchemas[key] = resolveRefs(schema, spec);
        resolvedSchemas[key]["additionalProperties"] = false;
    }
    return resolvedSchemas;
}

export function logTest(test: TestCaseType, body: string | undefined): void {
    console.log(chalk.bgBlue.white(' ‚û§ Test Details '));
    console.log(`${chalk.blueBright('üîç')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
    console.log(`${chalk.blueBright('üìù')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
    console.log(`${chalk.blueBright('üîó')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
    console.log(`${chalk.blueBright('üöÄ')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
    console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
    if (body) {
        console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Body:')} ${chalk.yellow(body)}`);
    }
    if (test.headers) {
        console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Headers:')} ${chalk.yellow(JSON.stringify(test.headers, null, 2))}`);
    }
    console.log(`${chalk.blueBright('‚úÖ')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
}


export async function buildOptions(spec: any, test: TestCaseType, testFileSettings: TestFileType): Promise<RequestOptions> {
    const server: string = spec.servers[0].url.replace("https://", "");
    const urlPart: string[] = server.split("/");
    const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

    let path = suffix ? `/${suffix}${test.path}` : test.path;

    if (test.params.query && test.params.query.length > 0) {
        const query = test.params.query
            .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
            .join("&");
        path += `?${query}`;
    }

    let headers = {
        'Content-Type': 'application/json',
    }

    if (test.headers) {
        test.headers.forEach(h => headers[h.name] = h.value);
    }

    // Add aut as header
    const authentication = test.authentication || testFileSettings.authentication
    if (authentication) {
        switch (authentication.type) {
            case 'bearer':
                const authenticationBearer: AuthenticationBearerType = authentication.value as AuthenticationBearerType;
                headers['authorization'] = `Bearer ${authenticationBearer.raw!}`;
                break;
            case 'oauth2':
                const authenticationOauth2: AuthenticationOauth2Type = authentication.value as AuthenticationOauth2Type;
                const parsedUrl = new URL(authenticationOauth2.access_token_url);
                const options: RequestOptions = {
                    host: parsedUrl.host,
                    port: 443,
                    path: parsedUrl.pathname,
                    method: 'POST',
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded"
                    }
                }
                const req = https.request(options, (res) => {
                    let responseBody: string = "";

                    res.on('data', (responseBodyData) => {
                        responseBody += responseBodyData;
                    });

                    res.on("end", () => {
                        const token: { access_token: string } = JSON.parse(responseBody);
                        headers['authorization'] = `Bearer ${token.access_token!}`;
                    });
                });

                req.write(new URLSearchParams({
                    'client_id': authenticationOauth2.client_id,
                    'client_secret': authenticationOauth2.client_secret,
                    'grant_type': authenticationOauth2.grant_type,
                    'scope': authenticationOauth2.scope
                }).toString())

                await req.end();
                break;
        }
    }

    return {
        host: urlPart[0],
        port: 443,
        path: path,
        method: test.method,
        headers: headers
    } as RequestOptions;
}

export async function sendRequest(options: RequestOptions, test: TestCaseType, body: string | undefined, callback: (response: http.IncomingMessage, responseBody: string) => void) {

    const req = https.request(options, (res) => {
        let responseBody: string = "";

        res.on('data', (responseBodyData) => {
            responseBody += responseBodyData;
        });

        res.on("end", () => {
            logTest(test, body);
            callback(res, responseBody);
        });
    });

    if ((options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') && body) {
        req.write(body);
    }

    await req.end();
}

export const defaultCommandHandler = (options: { input: string, spec: string }) => {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input)

        if (!spec || !tests) {
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const testsCases = tests.tests;
        const resolvedSchemas = extractAndResolveSchemas(spec);
        addSchemasToAjv(ajv, resolvedSchemas);

        // Run tests
        testsCases.forEach((test: TestCaseType, index: number) => {
            (async () => {
                const options: RequestOptions = await buildOptions(spec, test, tests);
                await sendRequest(options, test, JSON.stringify(test.body), (response: http.IncomingMessage, responseBody: string) => {
                    const statusCode: number | undefined = response.statusCode;

                    let valid = true;

                    // Handling and logging status code results with enhanced visibility
                    if (statusCode !== test.expected.status) {
                        console.error(chalk.bgRed.white(' ‚ùå Error: Status Code Mismatch'));
                        console.error(`${chalk.red('üö´ Expected Status Code:')} ${chalk.yellow(test.expected.status)}`);
                        console.error(`${chalk.red('üõë Received Status Code:')} ${chalk.yellow(statusCode)}`);
                        valid = false;
                    } else {
                        console.log(chalk.bgGreen.black(' ‚úÖ Success: Status Code Match'));
                        console.log(`${chalk.green('‚úîÔ∏è Status Code:')} ${chalk.white(statusCode)}`);
                    }

                    if (test.expected.body) {

                        // Retrive name of the ref
                        const schemaName = test.expected.body.ref;

                        if (!validateJson(schemaName, JSON.parse(responseBody))) {
                            console.error(chalk.bgRed.white(' ‚ùå Error: Response Body does not match schema'));
                            console.error(`${chalk.red('üö´ Expected Response Body schema:')} ${chalk.yellow(ajv.getSchema(schemaName))}`);
                            console.error(`${chalk.red('üõë Received Response Body:')} ${chalk.yellow(responseBody)}`);
                            valid = false;
                        } else {
                            console.log(chalk.bgGreen.black(' ‚úÖ Success: Response Body Match'));
                        }
                    }
                });
            })();
        });
    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }

};
