import chalk from "chalk";
import https, { RequestOptions } from 'https';
import http from "node:http";
import { OpenAPIV3 } from 'openapi-types';
import { AuthenticationBearerType, AuthenticationOauth2Type } from "../types/authentication.type";
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { getOpenApiFile, getOpenApiTestFile } from '../utils/files.util';
import { getSchemaFromOpenApi, validateSchema2 } from "../utils/schema.util";
import { validateCommandFunc } from "./validate.command";

export function logTest(test: TestCaseType, body: string | undefined, options: RequestOptions): void {
    console.log(chalk.bgBlue.white(' ‚û§ Test Details '));
    console.log(`${chalk.blueBright('üîç')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
    console.log(`${chalk.blueBright('üìù')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
    console.log(`${chalk.blueBright('üîó')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
    console.log(`${chalk.blueBright('üöÄ')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
    console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
    if (body) {
        console.log(`${chalk.blueBright('üßô‚Äç‚ôÇÔ∏è')} ${chalk.bold('Body:')} ${chalk.yellow(body)}`);
    }

    // Request headers are substraction of options headers and test headers
    const requestHeaders = { ...options.headers };
    if (test.headers) {
        test.headers.forEach(h => delete requestHeaders[h.name]);
    }

    if (test.headers) {
        console.log(`${chalk.blueBright('üë®')} ${chalk.bold('Headers:')} ${chalk.yellow(JSON.stringify(test.headers, null, 2))}`);
    }
    if (requestHeaders) {
        const maskedHeaders = { ...requestHeaders };
        if (maskedHeaders.Authorization) {
            maskedHeaders.Authorization = 'Bearer ********';
        }
        console.log(`${chalk.blueBright('üëÆ‚Äç‚ôÇÔ∏è')} ${chalk.bold('Request Headers:')} ${chalk.yellow(JSON.stringify(maskedHeaders, null, 2))}`);
    }
    console.log(`${chalk.blueBright('‚úÖ')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
}

async function getAccessToken(authenticationOauth2: AuthenticationOauth2Type): Promise<string> {
    return new Promise((resolve, reject) => {
        const parsedUrl = new URL(authenticationOauth2.accessTokenUrl);
        const options: RequestOptions = {
            host: parsedUrl.host,
            port: 443,
            path: parsedUrl.pathname,
            method: 'POST',
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        }
        const req = https.request(options, (res) => {
            let responseBody: string = "";

            res.on('data', (responseBodyData) => responseBody += responseBodyData);
            res.on("end", () => resolve(JSON.parse(responseBody).access_token));
            res.on("error", (error) => reject(error));
        });

        req.write(new URLSearchParams({
            'client_id': authenticationOauth2.clientId,
            'client_secret': authenticationOauth2.clientSecret,
            'grant_type': authenticationOauth2.grantType,
            'scope': authenticationOauth2.scope
        }).toString())

        req.end();
    });
}

export async function buildOptions(spec: any, test: TestCaseType, testFileSettings: TestFileType): Promise<RequestOptions> {
    return new Promise(async (resolve, reject) => {
        const server: string = spec.servers[0].url.replace("https://", "");
        const urlPart: string[] = server.split("/");
        const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

        let path = suffix ? `/${suffix}${test.path}` : test.path;

        if (test.params.query && test.params.query.length > 0) {
            const query = test.params.query
                .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
                .join("&");
            path += `?${query}`;
        }

        let headers = {
            'Content-Type': 'application/json',
        }

        if (test.headers) {
            test.headers.forEach(h => headers[h.name] = h.value);
        }


        const authentication = test.authentication || testFileSettings.authentication
        if (authentication) {
            switch (authentication.type) {
                case 'bearer': {
                    const authenticationBearer: AuthenticationBearerType = authentication.value as AuthenticationBearerType;
                    headers['Authorization'] = `Bearer ${authenticationBearer.raw}`;
                    resolve({
                        host: urlPart[0],
                        port: 443,
                        path: path,
                        method: test.method,
                        headers: headers
                    } as RequestOptions);
                    break;
                }
                case 'oauth2': {
                    const authenticationOauth2: AuthenticationOauth2Type = authentication.value as AuthenticationOauth2Type;
                    getAccessToken(authenticationOauth2).then(token => {
                        headers['Authorization'] = `Bearer ${token}`;
                        resolve({
                            host: urlPart[0],
                            port: 443,
                            path: path,
                            method: test.method,
                            headers: headers
                        } as RequestOptions);
                    }).catch((error) => {
                        console.error(`Error while getting access token: ${error}`);
                    });
                    break;
                }
                case 'none': {
                    resolve({
                        host: urlPart[0],
                        port: 443,
                        path: path,
                        method: test.method,
                        headers: headers
                    } as RequestOptions);
                } break;
            }
        }
    });
}

export async function sendRequest(options: RequestOptions, body: string | undefined): Promise<{ data: http.IncomingMessage, body: string }> {
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            let responseBody: string = "";
            res.on('data', (responseBodyData) => responseBody += responseBodyData);
            res.on("end", () => resolve({ data: res, body: responseBody }));
        });

        if ((options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') && body) {
            req.write(body);
        }

        req.end();
    });
}

export async function defaultCommandHandler(options: { input: string, spec: string }) {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input)

        if (!spec || !tests) {
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const testsCases = tests.tests;



        // Run tests
        for (let test of testsCases) {
            const options: RequestOptions = await buildOptions(spec, test, tests);
            const requestBody: string = JSON.stringify(test.body);
            const response: { data: http.IncomingMessage, body: string } = await sendRequest(options, requestBody);
            const statusCode: number | undefined = response.data.statusCode;
            const expectedResponse: { expectedStatusCode: boolean, expectedBody: boolean, data: TestCaseType } = {
                expectedStatusCode: true,
                expectedBody: true,
                data: test
            }

            logTest(test, requestBody, options);

            // Handling and logging status code results with enhanced visibility
            if (statusCode !== test.expected.status) {
                console.error(chalk.bgRed.white(' ‚ùå Error: Status Code Mismatch'));
                console.error(`${chalk.red('üö´ Expected Status Code:')} ${chalk.yellow(test.expected.status)}`);
                console.error(`${chalk.red('üõë Received Status Code:')} ${chalk.yellow(statusCode)}`);
                expectedResponse.expectedStatusCode = false;
            } else {
                console.log(chalk.bgGreen.black(' ‚úÖ Success: Status Code Match'));
                console.log(`${chalk.green('‚úîÔ∏è Status Code:')} ${chalk.white(statusCode)}`);
            }

            if (test.expected.body) {

                // Retrive name of the ref
                const schemaName = test.expected.body.ref;

                if (!validateSchema2(spec, schemaName, JSON.parse(response.body))) {
                    console.error(chalk.bgRed.white(' ‚ùå Error: Response Body does not match schema'));
                    console.error(`${chalk.red('üö´ Expected Response Body schema:')} ${chalk.yellow(getSchemaFromOpenApi(spec, schemaName))}`);
                    console.error(`${chalk.red('üõë Received Response Body:')} ${chalk.yellow(response.body)}`);
                    expectedResponse.expectedBody = false;
                } else {
                    console.log(chalk.bgGreen.black(' ‚úÖ Success: Response Body Match'));
                }
            }

        }

    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }

};
