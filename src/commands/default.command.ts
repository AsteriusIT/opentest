import https, {RequestOptions} from 'https';
import {TestCaseType} from '../types/testCase.type';
import {getOpenApiFile, getOpenApiTestFile} from '../utils/files.util';
import {TestFileType} from "../types/testFile.type";
import {validateCommandFunc} from "./validate.command";
import chalk from "chalk";
import http from "node:http";
import {OpenAPIV3} from 'openapi-types';
import Ajv from "ajv";

function extractSchemas(spec: OpenAPIV3.Document): OpenAPIV3.SchemaObject {
    return spec.components?.schemas ?? {};
}

const ajv = new Ajv({allErrors: true, strict: false});

// Load and compile schemas
function addSchemasToAjv(ajv: Ajv, schemas: Record<string, any>) {
    Object.entries(schemas).forEach(([key, schema]) => {
        ajv.addSchema(schema, key);
    });
}


// Validate JSON data against a specific schema
function validateJson(schemaName: string, jsonData: any) {
    const validate = ajv.getSchema(schemaName);
    if (!validate) {
        console.error(`Schema ${schemaName} not found.`);
        return;
    }
    const valid = validate(jsonData);
    if (!valid) {
        console.log('Validation errors:', validate.errors);
    } else {
        console.log('Validation successful!');
    }
}

function resolveRefs(obj: any, spec: any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => resolveRefs(item, spec));
    } else if (obj !== null && typeof obj === 'object') {
        if (obj.hasOwnProperty('$ref')) {
            const refPath = obj['$ref'].replace(/^#\//, '').split('/');
            let refObj = spec;
            for (const part of refPath) {
                refObj = refObj[part];
            }
            return resolveRefs(refObj, spec); // Recursively resolve nested refs
        }
        const newObj: any = {};
        for (const [key, value] of Object.entries(obj)) {
            newObj[key] = resolveRefs(value, spec);
        }
        return newObj;
    }
    return obj;
}

function extractAndResolveSchemas(spec: OpenAPIV3.Document): Record<string, any> {
    const schemas = spec.components?.schemas ?? {};
    const resolvedSchemas: any = {};
    for (const [key, schema] of Object.entries(schemas)) {
        resolvedSchemas[key] = resolveRefs(schema, spec);
    }
    return resolvedSchemas;
}

export function logTest(test: TestCaseType): void {
    console.log(chalk.bgBlue.white(' ‚û§ Test Details '));
    console.log(`${chalk.blueBright('üîç')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
    console.log(`${chalk.blueBright('üìù')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
    console.log(`${chalk.blueBright('üîó')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
    console.log(`${chalk.blueBright('üöÄ')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
    console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
    console.log(`${chalk.blueBright('‚úÖ')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
}


export function buildOptions(spec: any, test: TestCaseType): RequestOptions {
    const server: string = spec.servers[0].url.replace("https://", "");
    const urlPart: string[] = server.split("/");
    const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

    let path = suffix ? `/${suffix}${test.path}` : test.path;

    if (test.params.query && test.params.query.length > 0) {
        const query = test.params.query
            .map(({name, value}) => `${name}=${encodeURIComponent(value)}`)
            .join("&");
        path += `?${query}`;
    }

    return {
        host: urlPart[0],
        port: 443,
        path: path,
        method: test.method,
    } as RequestOptions;
}

export function sendRequest(options: RequestOptions, test: TestCaseType, callback: (response: http.IncomingMessage, responseBody: string) => void): void {
    https.request(options, (res) => {
        let responseBody: string = "";

        res.on('data', (responseBodyData) => {
            responseBody += responseBodyData;
        });

        res.on("end", () => {
            logTest(test);
            callback(res, responseBody);
        });
    }).end();
}

export const defaultCommandHandler = (options: { input: string, spec: string }) => {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input)

        if (!spec || !tests) {
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const testsCases = tests.tests;

        // Run tests
        testsCases.forEach((test: TestCaseType, index: number) => {
            const options: RequestOptions = buildOptions(spec, test);
            sendRequest(options, test, (response: http.IncomingMessage, responseBody: string) => {
                const statusCode: number | undefined = response.statusCode;

                // Handling and logging status code results with enhanced visibility
                if (statusCode !== test.expected.status) {
                    console.error(chalk.bgRed.white(' ‚ùå Error: Status Code Mismatch'));
                    console.error(`${chalk.red('üö´ Expected Status Code:')} ${chalk.yellow(test.expected.status)}`);
                    console.error(`${chalk.red('üõë Received Status Code:')} ${chalk.yellow(statusCode)}`);
                    process.exit(1);
                } else {
                    console.log(chalk.bgGreen.black(' ‚úÖ Success: Status Code Match'));
                    console.log(`${chalk.green('‚úîÔ∏è Status Code:')} ${chalk.white(statusCode)}`);
                }

                if (test.expected.bodySchema) {
                    const resolvedSchemas = extractAndResolveSchemas(spec);
                    addSchemasToAjv(ajv, resolvedSchemas);

                    const jsonData = { /* your JSON data */};
                    const schemaName = 'Pet'; // The name of the schema you want to validate against

                    validateJson(schemaName, JSON.parse(responseBody));

                }
            });
        });
    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }

};
