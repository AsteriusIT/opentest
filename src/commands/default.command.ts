import chalk from "chalk";
import https, { RequestOptions } from 'https';
import http from "node:http";
import { OpenAPIV3 } from 'openapi-types';
import { AuthenticationBearerType, AuthenticationOauth2Type } from "../types/authentication.type";
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { getOpenApiFile, getOpenApiTestFile } from '../utils/files.util';
import { getSchemaFromOpenApi, validateSchema2 } from "../utils/schema.util";
import { validateCommandFunc } from "./validate.command";
import { createObjectCsvWriter } from "csv-writer";
import fs from "fs";

export function logTest(test: TestCaseType, body: string | undefined, options: RequestOptions): void {
    console.log(chalk.bgBlue.white(' ‚û§ Test Details '));
    console.log(`${chalk.blueBright('üîç')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
    console.log(`${chalk.blueBright('üìù')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
    console.log(`${chalk.blueBright('üîó')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
    console.log(`${chalk.blueBright('üöÄ')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
    console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
    if (body) {
        console.log(`${chalk.blueBright('üßô‚Äç‚ôÇÔ∏è')} ${chalk.bold('Body:')} ${chalk.yellow(body)}`);
    }

    // Request headers are substraction of options headers and test headers
    const requestHeaders = { ...options.headers };
    if (test.headers) {
        test.headers.forEach(h => delete requestHeaders[h.name]);
    }

    if (test.headers) {
        console.log(`${chalk.blueBright('üë®')} ${chalk.bold('Headers:')} ${chalk.yellow(JSON.stringify(test.headers, null, 2))}`);
    }
    if (requestHeaders) {
        const maskedHeaders = { ...requestHeaders };
        if (maskedHeaders.Authorization) {
            maskedHeaders.Authorization = 'Bearer ********';
        }
        console.log(`${chalk.blueBright('üëÆ‚Äç‚ôÇÔ∏è')} ${chalk.bold('Request Headers:')} ${chalk.yellow(JSON.stringify(maskedHeaders, null, 2))}`);
    }
    console.log(`${chalk.blueBright('‚úÖ')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
}

async function getAccessToken(authenticationOauth2: AuthenticationOauth2Type): Promise<string> {
    return new Promise((resolve, reject) => {
        const parsedUrl = new URL(authenticationOauth2.accessTokenUrl);
        const options: RequestOptions = {
            host: parsedUrl.host,
            port: 443,
            path: parsedUrl.pathname,
            method: 'POST',
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        }
        const req = https.request(options, (res) => {
            let responseBody: string = "";

            res.on('data', (responseBodyData) => responseBody += responseBodyData);
            res.on("end", () => resolve(JSON.parse(responseBody).access_token));
            res.on("error", (error) => reject(error));
        });

        req.write(new URLSearchParams({
            'client_id': authenticationOauth2.clientId,
            'client_secret': authenticationOauth2.clientSecret,
            'grant_type': authenticationOauth2.grantType,
            'scope': authenticationOauth2.scope
        }).toString())

        req.end();
    });
}

export async function buildOptions(spec: any, test: TestCaseType, testFileSettings: TestFileType): Promise<RequestOptions> {
    return new Promise(async (resolve, reject) => {
        const server: string = spec.servers[0].url.replace("https://", "");
        const urlPart: string[] = server.split("/");
        const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

        let path = suffix ? `/${suffix}${test.path}` : test.path;

        if (test.params.query && test.params.query.length > 0) {
            const query = test.params.query
                .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
                .join("&");
            path += `?${query}`;
        }

        let headers = {
            'Content-Type': 'application/json',
        }

        if (test.headers) {
            test.headers.forEach(h => headers[h.name] = h.value);
        }


        const authentication = test.authentication || testFileSettings.authentication
        if (authentication) {
            switch (authentication.type) {
                case 'bearer': {
                    const authenticationBearer: AuthenticationBearerType = authentication.value as AuthenticationBearerType;
                    headers['Authorization'] = `Bearer ${authenticationBearer.raw}`;
                    resolve({
                        host: urlPart[0],
                        port: 443,
                        path: path,
                        method: test.method,
                        headers: headers
                    } as RequestOptions);
                    break;
                }
                case 'oauth2': {
                    const authenticationOauth2: AuthenticationOauth2Type = authentication.value as AuthenticationOauth2Type;
                    getAccessToken(authenticationOauth2).then(token => {
                        headers['Authorization'] = `Bearer ${token}`;
                        resolve({
                            host: urlPart[0],
                            port: 443,
                            path: path,
                            method: test.method,
                            headers: headers
                        } as RequestOptions);
                    }).catch((error) => {
                        console.error(`Error while getting access token: ${error}`);
                    });
                    break;
                }
                case 'none': {
                    resolve({
                        host: urlPart[0],
                        port: 443,
                        path: path,
                        method: test.method,
                        headers: headers
                    } as RequestOptions);
                } break;
            }
        }
    });
}

export async function sendRequest(options: RequestOptions, body: string | undefined): Promise<{ data: http.IncomingMessage, body: string }> {
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            let responseBody: string = "";
            res.on('data', (responseBodyData) => responseBody += responseBodyData);
            res.on("end", () => resolve({ data: res, body: responseBody }));
        });

        if ((options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') && body) {
            req.write(body);
        }

        req.end();
    });
}

async function saveTestsToCsv(tests: { expectedStatusCode: boolean, expectedBody: boolean, data: TestCaseType }[]): Promise<void> {
    const csvWriter = createObjectCsvWriter({
        path: 'tests.csv',
        encoding: 'utf8',
        header: [
            { id: 'name', title: 'Name' },
            { id: 'description', title: 'Description' },
            { id: 'path', title: 'Path' },
            { id: 'method', title: 'Method' },
            { id: 'params', title: 'Params' },
            { id: 'body', title: 'Body' },
            { id: 'expected', title: 'Expected' },
            { id: 'response_status_code', title: 'Response Status Code' },
            { id: 'response_body', title: 'Response Body' }
        ]
    });

    const records = tests.map(test => {
        return {
            name: test.data.name,
            description: test.data.description,
            path: test.data.path,
            method: test.data.method,
            params: JSON.stringify(test.data.params),
            body: JSON.stringify(test.data.body),
            expected: JSON.stringify(test.data.expected),
            response_status_code: test.expectedStatusCode,
            response_body: test.expectedBody
        }
    });

    return await csvWriter.writeRecords(records);
}

function saveResponsesIntoJsonFile(output: string, responses: { passed: boolean, errors: any[], data: TestCaseType }[]): void {
    const data = responses.map(response => {
        return {
            name: response.data.name,
            description: response.data.description,
            errors: response.errors
        }
    });

    const json = JSON.stringify(data, null, 2);
    fs.writeFileSync(output, json);
}

export async function defaultCommandHandler(options: { input: string, spec: string, output: string | undefined }) {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input)

        if (!spec || !tests) {
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const testsCases = tests.tests;
        const responses: { passed: boolean, errors: any[], data: TestCaseType }[] = [];

        // Run tests
        for (let test of testsCases) {
            const requestOptions: RequestOptions = await buildOptions(spec, test, tests);
            const requestBody: string = JSON.stringify(test.body);
            const response: { data: http.IncomingMessage, body: string } = await sendRequest(requestOptions, requestBody);
            const statusCode: number | undefined = response.data.statusCode;
            const expectedResponse: { passed: boolean, errors: any[], data: TestCaseType } = {
                passed: true,
                errors: [],
                data: test
            }

            logTest(test, requestBody, requestOptions);

            // Handling and logging status code results with enhanced visibility
            if (statusCode !== test.expected.status) {
                console.error(chalk.bgRed.white(' ‚ùå Error: Status Code Mismatch'));
                console.error(`${chalk.red('üö´ Expected Status Code:')} ${chalk.yellow(test.expected.status)}`);
                console.error(`${chalk.red('üõë Received Status Code:')} ${chalk.yellow(statusCode)}`);
                expectedResponse.passed = false;
                expectedResponse.errors.push({
                    test: 'status_code',
                    valid: false,
                    expected: test.expected.status,
                    received: statusCode
                });
            } else {
                console.log(chalk.bgGreen.black(' ‚úÖ Success: Status Code Match'));
                console.log(`${chalk.green('‚úîÔ∏è Status Code:')} ${chalk.white(statusCode)}`);

                expectedResponse.errors.push({
                    test: 'status_code',
                    valid: true,
                    expected: test.expected.status,
                    received: statusCode
                });
            }

            if (test.expected.body) {

                // Retrive name of the ref
                const schemaName = test.expected.body.ref;

                if (!validateSchema2(spec, schemaName, JSON.parse(response.body))) {
                    console.error(chalk.bgRed.white(' ‚ùå Error: Response Body does not match schema'));
                    console.error(`${chalk.red('üö´ Expected Response Body schema:')} ${chalk.yellow(getSchemaFromOpenApi(spec, schemaName))}`);
                    console.error(`${chalk.red('üõë Received Response Body:')} ${chalk.yellow(response.body)}`);
                    expectedResponse.passed = false;
                    expectedResponse.errors.push({
                        test: 'response_body',
                        valid: false,
                        expected: getSchemaFromOpenApi(spec, schemaName),
                        received: response.body
                    });
                } else {
                    console.log(chalk.bgGreen.black(' ‚úÖ Success: Response Body Match'));

                    expectedResponse.errors.push({
                        test: 'response_body',
                        valid: true,
                        expected: getSchemaFromOpenApi(spec, schemaName),
                        received: response.body
                    });
                }
            }

            responses.push(expectedResponse);
        }

        if (options.output) {
            saveResponsesIntoJsonFile(options.output, responses);
        }
    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }

};
