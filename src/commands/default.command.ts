import { OpenAPIV3 } from 'openapi-types';
import { ApiRequestHandler } from "../handlers/apiRequest.handler";
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { getOpenApiFile, getOpenApiTestFile } from '../utils/files.util';
import { ConsoleLogger, ILogger, JsonLogger } from '../utils/logger.util';
import { createSchemaValidator } from "../utils/schema.util";
import { validateCommandFunc } from "./validate.command";

class TestRunner {
    private tests: TestFileType;
    private logger: ILogger;
    private apiHandler: ApiRequestHandler;
    private schemaValidator: any;

    constructor(spec: OpenAPIV3.Document, tests: TestFileType, logger: ILogger) {
        this.tests = tests;
        this.logger = logger;
        this.apiHandler = new ApiRequestHandler(spec);
        this.schemaValidator = createSchemaValidator(spec);
    }

    async runTests(): Promise<{ passed: boolean, errors: any[], data: TestCaseType }[]> {
        const responses: { passed: boolean, errors: any[], data: TestCaseType }[] = [];

        for (let test of this.tests.tests) {
            const response = await this.runSingleTest(test);
            responses.push(response);
        }

        return responses;
    }

    private async runSingleTest(test: TestCaseType): Promise<{ passed: boolean, errors: any[], data: TestCaseType }> {
        const options = await this.apiHandler.buildOptions(test, this.tests);
        const requestBody: string = JSON.stringify(test.body);
        const response = await this.apiHandler.sendRequest(options, requestBody);

        const statusCode: number | undefined = response.data.statusCode;
        const expectedResponse: { passed: boolean, errors: any[], data: TestCaseType } = {
            passed: true,
            errors: [],
            data: test
        };

        this.logger.logTest(test, requestBody, options);

        this.validateStatusCode(test, statusCode, expectedResponse);
        this.validateResponseBody(test, response.body, expectedResponse);

        return expectedResponse;
    }

    private validateStatusCode(test: TestCaseType, statusCode: number | undefined, expectedResponse: { passed: boolean, errors: any[] }): void {
        this.logger.logStatusCodeResult(test.expected.status, statusCode);
        if (statusCode !== test.expected.status) {
            expectedResponse.passed = false;
        }

        expectedResponse.errors.push({
            test: 'status_code',
            valid: statusCode === test.expected.status,
            expected: test.expected.status,
            received: statusCode
        });
    }

    private validateResponseBody(test: TestCaseType, responseBody: string, expectedResponse: { passed: boolean, errors: any[] }): void {
        if (!test.expected.body) return;

        if (test.expected.body.ref) {
            this.validateBodySchema(test.expected.body.ref, responseBody, expectedResponse);
        }

        if (test.expected.body.value) {
            this.validateBodyValue(test.expected.body.value, responseBody, expectedResponse);
        }
    }

    private validateBodySchema(schemaRef: string, responseBody: string, expectedResponse: { passed: boolean, errors: any[] }): void {
        const schema = this.schemaValidator.getSchemaFromOpenApi(schemaRef);
        const isValid = this.schemaValidator.validateJson(schemaRef, JSON.parse(responseBody));

        if (!isValid) {
            this.logger.logBodyResult(schema, responseBody, schema);
            expectedResponse.passed = false;
        } else {
            this.logger.logBodyResultSuccess(true);
        }

        expectedResponse.errors.push({
            test: 'response_body_schema',
            valid: isValid,
            expected: schema,
            received: responseBody
        });
    }

    private validateBodyValue(expectedValue: any, responseBody: string, expectedResponse: { passed: boolean, errors: any[] }): void {
        this.logger.logBodyResult(expectedValue, responseBody);
        const isValid = JSON.stringify(expectedValue) === JSON.stringify(JSON.parse(responseBody));

        if (!isValid) {
            expectedResponse.passed = false;
        } else {
            this.logger.logBodyResultSuccess(false);
        }

        expectedResponse.errors.push({
            test: 'response_body_value',
            valid: isValid,
            expected: expectedValue,
            received: responseBody
        });
    }
}

export async function defaultCommandHandler(options: { input: string, spec: string, output: string | undefined, format?: 'console' | 'json' }) {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input);

        if (!spec || !tests) {
            console.error('Failed to load spec or tests');
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const logger: ILogger = options.format === 'json' ? new JsonLogger() : new ConsoleLogger();
        const testRunner = new TestRunner(spec, tests, logger);

        const responses = await testRunner.runTests();

        if (options.output) {
            logger.saveResponses(options.output, responses);
        }
    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }
}
