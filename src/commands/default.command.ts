import Ajv from "ajv";
import chalk from "chalk";
import https, { RequestOptions } from 'https';
import http from "node:http";
import { OpenAPIV3 } from 'openapi-types';
import { TestCaseType } from '../types/testCase.type';
import { TestFileType } from "../types/testFile.type";
import { getOpenApiFile, getOpenApiTestFile } from '../utils/files.util';
import { validateCommandFunc } from "./validate.command";

function extractSchemas(spec: OpenAPIV3.Document): OpenAPIV3.SchemaObject {
    return spec.components?.schemas ?? {};
}

const ajv = new Ajv({ allErrors: true, strict: false });

// Load and compile schemas
function addSchemasToAjv(ajv: Ajv, schemas: Record<string, any>) {
    Object.entries(schemas).forEach(([key, schema]) => {
        ajv.addSchema(schema, key);
    });
}


// Validate JSON data against a specific schema
function validateJson(schemaName: string, jsonData: any) {
    const validate = ajv.getSchema(schemaName);
    if (!validate) {
        console.error(`Schema ${schemaName} not found.`);
        return;
    }
    const valid = validate(jsonData);
    if (!valid) {
        console.log('Validation errors:', validate.errors);
    } else {
        console.log('Validation successful!');
    }

    return valid;
}

function resolveRefs(obj: any, spec: any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => resolveRefs(item, spec));
    } else if (obj !== null && typeof obj === 'object') {
        if (obj.hasOwnProperty('$ref')) {
            const refPath = obj['$ref'].replace(/^#\//, '').split('/');
            let refObj = spec;
            for (const part of refPath) {
                refObj = refObj[part];
            }
            return resolveRefs(refObj, spec); // Recursively resolve nested refs
        }
        const newObj: any = {};
        for (const [key, value] of Object.entries(obj)) {
            newObj[key] = resolveRefs(value, spec);
        }
        return newObj;
    }
    return obj;
}

function extractAndResolveSchemas(spec: OpenAPIV3.Document): Record<string, any> {
    const schemas = spec.components?.schemas ?? {};
    const resolvedSchemas: any = {};
    for (const [key, schema] of Object.entries(schemas)) {
        resolvedSchemas[key] = resolveRefs(schema, spec);
        resolvedSchemas[key]["additionalProperties"] = false;        
    }
    return resolvedSchemas;
}

export function logTest(test: TestCaseType, body: string | undefined): void {
    console.log(chalk.bgBlue.white(' ‚û§ Test Details '));
    console.log(`${chalk.blueBright('üîç')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
    console.log(`${chalk.blueBright('üìù')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
    console.log(`${chalk.blueBright('üîó')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
    console.log(`${chalk.blueBright('üöÄ')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
    console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
    if (body) {
        console.log(`${chalk.blueBright('üîß')} ${chalk.bold('Body:')} ${chalk.yellow(body)}`);
    }
    console.log(`${chalk.blueBright('‚úÖ')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);
}


export function buildOptions(spec: any, test: TestCaseType): RequestOptions {
    const server: string = spec.servers[0].url.replace("https://", "");
    const urlPart: string[] = server.split("/");
    const suffix = urlPart.length > 1 ? urlPart.slice(1).join("/") : "";

    let path = suffix ? `/${suffix}${test.path}` : test.path;

    if (test.params.query && test.params.query.length > 0) {
        const query = test.params.query
            .map(({ name, value }) => `${name}=${encodeURIComponent(value)}`)
            .join("&");
        path += `?${query}`;
    }

    let headers = {
        'Content-Type': 'application/json',
    }

    // Add aut as header
    if (test.authentication) {
        headers['authorization'] = `Bearer ${test.authentication!}`;
    }

    return {
        host: urlPart[0],
        port: 443,
        path: path,
        method: test.method,
        headers: headers
    } as RequestOptions;
}

export function sendRequest(options: RequestOptions, test: TestCaseType, body: string | undefined, callback: (response: http.IncomingMessage, responseBody: string) => void): void {

    const req = https.request(options, (res) => {
        let responseBody: string = "";

        res.on('data', (responseBodyData) => {
            responseBody += responseBodyData;
        });

        res.on("end", () => {
            logTest(test, body);
            callback(res, responseBody);
        });
    });

    if ((options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') && body) {
        req.write(body);
    }

    req.end();
}

export const defaultCommandHandler = (options: { input: string, spec: string }) => {
    try {
        const spec: OpenAPIV3.Document = getOpenApiFile(options.spec);
        const tests: TestFileType = getOpenApiTestFile(options.input)

        if (!spec || !tests) {
            process.exit(1);
        }

        validateCommandFunc(options.input);

        const testsCases = tests.tests;
        const resolvedSchemas = extractAndResolveSchemas(spec);
        addSchemasToAjv(ajv, resolvedSchemas);

        // Run tests
        testsCases.forEach((test: TestCaseType, index: number) => {
            const options: RequestOptions = buildOptions(spec, test);
            sendRequest(options, test, JSON.stringify(test.body), (response: http.IncomingMessage, responseBody: string) => {
                const statusCode: number | undefined = response.statusCode;

                let valid = true;

                // Handling and logging status code results with enhanced visibility
                if (statusCode !== test.expected.status) {
                    console.error(chalk.bgRed.white(' ‚ùå Error: Status Code Mismatch'));
                    console.error(`${chalk.red('üö´ Expected Status Code:')} ${chalk.yellow(test.expected.status)}`);
                    console.error(`${chalk.red('üõë Received Status Code:')} ${chalk.yellow(statusCode)}`);
                    valid = false;
                } else {
                    console.log(chalk.bgGreen.black(' ‚úÖ Success: Status Code Match'));
                    console.log(`${chalk.green('‚úîÔ∏è Status Code:')} ${chalk.white(statusCode)}`);
                }

                if (test.expected.body) {

                    // Retrive name of the ref
                    const schemaName = test.expected.body.ref;

                    if (!validateJson(schemaName, JSON.parse(responseBody))) {
                        console.error(chalk.bgRed.white(' ‚ùå Error: Response Body does not match schema'));
                        console.error(`${chalk.red('üö´ Expected Response Body schema:')} ${chalk.yellow(ajv.getSchema(schemaName))}`);
                        console.error(`${chalk.red('üõë Received Response Body:')} ${chalk.yellow(responseBody)}`);
                        valid = false;
                    } else {
                        console.log(chalk.bgGreen.black(' ‚úÖ Success: Response Body Match'));
                    }
                }
            });
        });
    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error(`Error while reading or parsing file: ${error.message}`);
            process.exit(1);
        }
    }

};
