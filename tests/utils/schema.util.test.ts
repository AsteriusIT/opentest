import { OpenAPIV3 } from "openapi-types";
import { TestFileType } from "../../src/types/testFile.type";
import { createSchemaValidator, SchemaValidator, validateOpentestSchema } from '../../src/utils/schema.util';

const validTestFileType: TestFileType = {
    tests: [
        {
            name: "find by available pets",
            description: "Should return all available pets",
            path: "/pet/findByStatus",
            method: "GET",
            params: {
                query: [
                    {
                        name: "status",
                        value: "available"
                    }
                ]
            },
            expected: {
                status: 200
            }
        }
    ]
}
const invalidTestFileType: TestFileType = {
    tests: [
        {
            name: "find by available pets",
            description: "Should return all available pets",
            path: "findByStatus",
            method: "GET",
            params: {
                query: [
                    {
                        name: "status",
                        value: "available"
                    }
                ]
            },
            expected: {
                status: 200
            }
        }
    ]
}
describe('testing schema validation', () => {
    test('valid test object should return success', () => {
        expect(validateOpentestSchema(validTestFileType)).toStrictEqual({ "errors": null, "success": true });
    });
    test('invalid path test object should return error', () => {
        expect(validateOpentestSchema(invalidTestFileType)).toStrictEqual({
            "errors": [
                {
                    "instancePath": "/tests/0/path",
                    "keyword": "pattern",
                    "message": "must match pattern \"^/.*$\"",
                    "params": {
                        "pattern": "^/.*$",
                    },
                    "schemaPath": "#/properties/tests/items/properties/path/pattern",
                },
            ], "success": false
        })
            ;
    });
});

describe('SchemaValidator', () => {
    let validator: SchemaValidator;
    let mockSpec: OpenAPIV3.Document;

    beforeEach(() => {
        // Set up a mock OpenAPI spec for testing
        mockSpec = {
            openapi: '3.0.0',
            info: {
                title: 'Test API',
                version: '1.0.0',
            },
            paths: {},
            components: {
                schemas: {
                    TestSchema: {
                        type: 'object',
                        properties: {
                            name: { type: 'string' },
                            age: { type: 'number' }
                        },
                        required: ['name', 'age']
                    },
                    NestedSchema: {
                        type: 'object',
                        properties: {
                            id: { type: 'number' },
                            details: { $ref: '#/components/schemas/TestSchema' }
                        },
                        required: ['id', 'details']
                    }
                }
            }
        } as OpenAPIV3.Document;

        // Create a new validator instance before each test
        validator = createSchemaValidator(mockSpec);
    });

    describe('validateJson', () => {
        test('should return success for valid data', () => {
            const validData = { name: 'John', age: 30 };
            const result = validator.validateJson('TestSchema', validData);
            expect(result.success).toBe(true);
            expect(result.errors).toBeUndefined();
        });

        test('should return errors for invalid data', () => {
            const invalidData = { name: 'John' };
            const result = validator.validateJson('TestSchema', invalidData);
            expect(result.success).toBe(false);
            expect(result.errors).toBeDefined();
            expect(result.errors?.[0].message).toContain("must have required property 'age'");
        });

        test('should throw error for non-existent schema', () => {
            expect(() => {
                validator.validateJson('NonExistentSchema', {});
            }).toThrow('Schema NonExistentSchema not found.');
        });

        test('should validate nested schemas', () => {
            const validData = { id: 1, details: { name: 'John', age: 30 } };
            const result = validator.validateJson('NestedSchema', validData);
            expect(result.success).toBe(true);
        });
    });

    describe('getSchemaFromOpenApi', () => {
        test('should return the correct schema', () => {
            const schema = validator.getSchemaFromOpenApi('TestSchema');
            expect(schema).toEqual(mockSpec.components?.schemas?.TestSchema);
        });

        test('should throw error for non-existent schema', () => {
            expect(() => validator.getSchemaFromOpenApi('NonExistentSchema')).toThrow('Schema NonExistentSchema not found.');
        });
    });

    // Additional tests can be added here for other methods if they're made public
});