import { ConsoleLogger, JsonLogger } from '../../src/utils/logger.util';
import chalk from 'chalk';
import fs from 'fs';
import { TestCaseType } from '../../src/types/testCase.type';
import { RequestOptions } from 'https';

jest.mock('chalk', () => ({
    bgBlue: { white: jest.fn((str) => str) },
    blueBright: jest.fn((str) => str),
    bold: jest.fn((str) => str),
    green: jest.fn((str) => str),
    blue: jest.fn((str) => str),
    magenta: jest.fn((str) => str),
    cyan: jest.fn((str) => str),
    yellow: jest.fn((str) => str),
    white: jest.fn((str) => str),
    bgRed: { white: jest.fn((str) => str) },
    red: jest.fn((str) => str),
    bgGreen: { black: jest.fn((str) => str) },
}));

jest.mock('fs', () => ({
    writeFileSync: jest.fn(),
}));

describe('ConsoleLogger', () => {
    let consoleLogger: ConsoleLogger;
    let consoleLogSpy: jest.SpyInstance;
    let consoleErrorSpy: jest.SpyInstance;

    beforeEach(() => {
        consoleLogger = new ConsoleLogger();
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
    });

    afterEach(() => {
        consoleLogSpy.mockRestore();
        consoleErrorSpy.mockRestore();
    });

    test('logTest logs test details correctly', () => {
        const testCase: TestCaseType = {
            name: 'Test Case',
            description: 'Test Description',
            path: '/test',
            method: 'GET',
            params: { query: [] },
            expected: { status: 200 }
        };
        const body = '{"key": "value"}';
        const options: RequestOptions = { headers: { 'Content-Type': 'application/json' } };

        consoleLogger.logTest(testCase, body, options);

        expect(consoleLogSpy).toHaveBeenCalledTimes(9);
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Test Details'));
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Test Case'));
    });

    test('logStatusCodeResult logs success correctly', () => {
        consoleLogger.logStatusCodeResult(200, 200);

        expect(consoleLogSpy).toHaveBeenCalledTimes(2);
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Success: Status Code Match'));
    });

    test('logStatusCodeResult logs error correctly', () => {
        consoleLogger.logStatusCodeResult(200, 404);

        expect(consoleErrorSpy).toHaveBeenCalledTimes(3);
        expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Error: Status Code Mismatch'));
    });

    test('logBodyResult logs success correctly', () => {
        const expected = { key: 'value' };
        const received = JSON.stringify(expected);

        consoleLogger.logBodyResult(expected, received);

        expect(consoleLogSpy).toHaveBeenCalledTimes(1);
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Success: Response Body Match'));
    });

    test('logBodyResult logs error correctly', () => {
        const expected = { key: 'value' };
        const received = JSON.stringify({ key: 'different value' });

        consoleLogger.logBodyResult(expected, received);

        expect(consoleErrorSpy).toHaveBeenCalledTimes(3);
        expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Error: Response Body Mismatch'));
    });

    test('logBodyResultSuccess logs success correctly', () => {
        consoleLogger.logBodyResultSuccess(true);

        expect(consoleLogSpy).toHaveBeenCalledTimes(1);
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Success: Response Body Match Schema'));
    });

    test('saveResponses saves responses correctly', () => {
        const responses = [
            { passed: true, errors: [], data: { name: 'Test 1', description: 'Description 1' } as TestCaseType },
            { passed: false, errors: ['Error'], data: { name: 'Test 2', description: 'Description 2' } as TestCaseType }
        ];

        consoleLogger.saveResponses('output.json', responses);

        expect(fs.writeFileSync).toHaveBeenCalledWith('output.json', expect.any(String));
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Results saved to output.json'));
    });
});

describe('JsonLogger', () => {
    let jsonLogger: JsonLogger;

    beforeEach(() => {
        jsonLogger = new JsonLogger();
    });

    test('logTest adds test details to logs', () => {
        const testCase: TestCaseType = {
            name: 'Test Case',
            description: 'Test Description',
            path: '/test',
            method: 'GET',
            params: { query: [] },
            expected: { status: 200 }
        };
        const body = '{"key": "value"}';
        const options: RequestOptions = { headers: { 'Content-Type': 'application/json' } };

        jsonLogger.logTest(testCase, body, options);

        expect((jsonLogger as any).logs).toHaveLength(1);
        expect((jsonLogger as any).logs[0]).toEqual({
            type: 'test_details',
            test: testCase,
            body: body,
            options: options
        });
    });

    test('logStatusCodeResult adds status code result to logs', () => {
        jsonLogger.logStatusCodeResult(200, 200);

        expect((jsonLogger as any).logs).toHaveLength(1);
        expect((jsonLogger as any).logs[0]).toEqual({
            type: 'status_code_result',
            expected: 200,
            received: 200,
            passed: true
        });
    });

    test('logBodyResult adds body result to logs', () => {
        const expected = { key: 'value' };
        const received = JSON.stringify(expected);

        jsonLogger.logBodyResult(expected, received);

        expect((jsonLogger as any).logs).toHaveLength(1);
        expect((jsonLogger as any).logs[0]).toEqual({
            type: 'body_result',
            expected: expected,
            received: expected,
            schema: undefined,
            passed: true
        });
    });

    test('logBodyResultSuccess throws not implemented error', () => {
        expect(() => jsonLogger.logBodyResultSuccess()).toThrow('Method not implemented.');
    });
});