import { OpenAPIV3 } from 'openapi-types';
import { defaultCommandHandler } from '../../src/commands/default.command';
import { validateCommandFunc } from '../../src/commands/validate.command';
import { getOpenApiFile, getOpenApiTestFile } from '../../src/utils/files.util';
import { ConsoleLogger, JsonLogger } from '../../src/utils/logger.util';
import { TestRunner } from '../../src/handlers/testRunner.handler';

jest.mock('../../src/utils/files.util');
jest.mock('../../src/commands/validate.command');
jest.mock('../../src/utils/logger.util');
jest.mock('../../src/handlers/testRunner.handler');


describe('defaultCommandHandler', () => {
    const mockExit = jest.spyOn(process, 'exit').mockImplementation((number) => { throw new Error('process.exit: ' + number); });
    const mockConsoleError = jest.spyOn(console, 'error').mockImplementation(() => { });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    afterAll(() => {
        mockExit.mockRestore();
        mockConsoleError.mockRestore();
    });

    it('should run tests and save responses when all inputs are valid', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: 'output.json',
            format: 'json' as const
        };

        const mockSpec = {} as OpenAPIV3.Document;
        const mockTests = { tests: [] };
        (getOpenApiFile as jest.Mock).mockReturnValue(mockSpec);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(mockTests);
        (TestRunner.prototype.runTests as jest.Mock).mockResolvedValue([]);

        await defaultCommandHandler(options);

        expect(getOpenApiFile).toHaveBeenCalledWith(options.spec);
        expect(getOpenApiTestFile).toHaveBeenCalledWith(options.input);
        expect(validateCommandFunc).toHaveBeenCalledWith(options.input);
        expect(JsonLogger.prototype.saveResponses).toHaveBeenCalledWith(options.output, []);
    });

    it('should use ConsoleLogger when format is console', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: 'output.txt',
            format: 'console' as const
        };

        const mockSpec = {} as OpenAPIV3.Document;
        const mockTests = { tests: [] };
        (getOpenApiFile as jest.Mock).mockReturnValue(mockSpec);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(mockTests);
        (TestRunner.prototype.runTests as jest.Mock).mockResolvedValue([]);

        await defaultCommandHandler(options);

        expect(ConsoleLogger).toHaveBeenCalled();
        expect(JsonLogger).not.toHaveBeenCalled();
    });

    it('should not save responses when output is not provided', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: undefined,
            format: 'json' as const
        };

        const mockSpec = {} as OpenAPIV3.Document;
        const mockTests = { tests: [] };
        (getOpenApiFile as jest.Mock).mockReturnValue(mockSpec);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(mockTests);
        (TestRunner.prototype.runTests as jest.Mock).mockResolvedValue([]);

        await defaultCommandHandler(options);

        expect(JsonLogger.prototype.saveResponses).not.toHaveBeenCalled();
    });

    it('should exit with error when spec fails to load', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: 'output.json',
            format: 'json' as const
        };

        (getOpenApiFile as jest.Mock).mockReturnValue(null);
        (getOpenApiTestFile as jest.Mock).mockReturnValue({ tests: [] });

        await expect(defaultCommandHandler(options)).rejects.toThrow('process.exit: 1');

        expect(mockConsoleError).toHaveBeenCalledWith('Failed to load spec or tests');
        expect(mockExit).toHaveBeenCalledWith(1);
    });

    it('should exit with error when tests fail to load', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: 'output.json',
            format: 'json' as const
        };

        (getOpenApiFile as jest.Mock).mockReturnValue({} as OpenAPIV3.Document);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(null);

        await expect(defaultCommandHandler(options)).rejects.toThrow('process.exit: 1');

        expect(mockConsoleError).toHaveBeenCalledWith('Failed to load spec or tests');
        expect(mockExit).toHaveBeenCalledWith(1);
    });

    it('should handle errors during file reading or parsing', async () => {
        const options = {
            input: 'input.yml',
            spec: 'spec.yml',
            output: 'output.json',
            format: 'json' as const
        };

        const mockError = new Error('File read error');
        (getOpenApiFile as jest.Mock).mockImplementation(() => { throw mockError; });

        await expect(defaultCommandHandler(options)).rejects.toThrow('process.exit: 1');

        expect(mockConsoleError).toHaveBeenCalledWith('Error while reading or parsing file: File read error');
        expect(mockExit).toHaveBeenCalledWith(1);
    });
});