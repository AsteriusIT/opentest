import chalk from "chalk";
import { RequestOptions } from "https";
import { OpenAPIV3 } from "openapi-types";
import { buildOptions, logTest } from "../../src/commands/default.command";
import { TestCaseType } from "../../src/types/testCase.type";
import { TestFileType } from "../../src/types/testFile.type";

const validOpenApiType: OpenAPIV3.Document = {
    openapi: "3.0.0",
    info: {
        title: "Swagger Petstore",
        version: "1.0.0"
    },
    servers: [
        { url: "api.example.com", description: "description" }
    ],
    paths: {}
}
const validOpenApiTypeWithSuffix: OpenAPIV3.Document = {
    openapi: "3.0.0",
    info: {
        title: "Swagger Petstore",
        version: "1.0.0"
    },
    servers: [
        { url: "api.example.com/v1", description: "description" }
    ],
    paths: {}
}

jest.mock('https');

describe('logTest', () => {
    let mockConsoleLog: jest.SpyInstance;

    // Set up mock for console.log before each test
    beforeEach(() => {
        mockConsoleLog = jest.spyOn(console, 'log').mockImplementation(() => { });
    });

    // Clear all mocks after each test
    afterEach(() => {
        jest.clearAllMocks();
    });

    test('should log the correct test information', () => {
        // Example test case object
        const test: TestCaseType = {
            name: 'User Login Test',
            description: 'Test to validate user login API',
            path: '/api/v1/login',
            method: 'POST',
            params: { query: [] },
            expected: { status: 200 }
        };

        // Call the logTest function
        logTest(test, undefined, {});

        // Verify that console.log was called with the correct arguments
        expect(mockConsoleLog).toHaveBeenCalledWith(chalk.bgBlue.white(' ➤ Test Details '));
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('🔍')} ${chalk.bold('Test Name:')} ${chalk.green(test.name)}`);
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('📝')} ${chalk.bold('Description:')} ${chalk.blue(test.description)}`);
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('🔗')} ${chalk.bold('Path:')} ${chalk.magenta(test.path)}`);
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('🚀')} ${chalk.bold('Method:')} ${chalk.cyan(test.method)}`);
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('🔧')} ${chalk.bold('Params:')} ${chalk.yellow(JSON.stringify(test.params, null, 2))}`);
        expect(mockConsoleLog).toHaveBeenCalledWith(`${chalk.blueBright('✅')} ${chalk.bold('Expected:')} ${chalk.white(JSON.stringify(test.expected, null, 2))}`);

        // Check the total number of console.log calls (7 logs in total)
        expect(mockConsoleLog).toHaveBeenCalledTimes(8);
    });
});

describe('buildOptions', () => {
    test('should construct RequestOptions without query parameters', () => {
        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [],
            },
            expected: {
                status: 200
            }
        };
        const validTestFileType: TestFileType = {
            tests: [test],
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/users',
            method: 'GET',
        };

        buildOptions(validOpenApiType, test, validTestFileType).then((result) => {
            expect(result).toEqual(expected);
        });
    });

    test('should construct RequestOptions with query parameters', () => {
        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [
                    { name: 'name', value: 'john' },
                    { name: 'age', value: '25' },
                ],
            },
            expected: {
                status: 200
            }
        };
        const validTestFileType: TestFileType = {
            tests: [test],
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/users?name=john&age=25',
            method: 'GET',
        };

        buildOptions(validOpenApiType, test, validTestFileType).then((result) => {
            expect(result).toEqual(expected);
        });
    });

    test('should construct RequestOptions when server URL has a suffix', () => {
        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [],
            },
            expected: {
                status: 200
            }
        };
        const validTestFileType: TestFileType = {
            tests: [test],
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/v1/users',
            method: 'GET',
        };

        buildOptions(validOpenApiType, test, validTestFileType).then((result) => {
            expect(result).toEqual(expected);
        });
    });

    test('should construct RequestOptions with query parameters and a server URL suffix', () => {
        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [
                    { name: 'role', value: 'admin' },
                ],
            },
            expected: {
                status: 200
            }
        };
        const validTestFileType: TestFileType = {
            tests: [test],
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/v1/users?role=admin',
            method: 'GET',
        };

        buildOptions(validOpenApiType, test, validTestFileType).then((result) => {
            expect(result).toEqual(expected);
        });
    });
});