import {TestCaseType} from "../../src/types/testCase.type";
import {buildOptions, logTest, sendRequest} from "../../src/commands/default.command";
import {OpenapiType} from "../../src/types/openapi.type";
import https, {RequestOptions} from "https";

jest.mock('https');

describe('logTest', () => {
    let mockConsoleLog: jest.SpyInstance;

    // Set up mock for console.log before each test
    beforeEach(() => {
        mockConsoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});
    });

    // Clear all mocks after each test
    afterEach(() => {
        jest.clearAllMocks();
    });

    test('should log the correct test information', () => {
        // Example test case object
        const test: TestCaseType = {
            name: 'User Login Test',
            description: 'Test to validate user login API',
            path: '/api/v1/login',
            method: 'POST',
            params: { query: [] },
            expected: { status: 200 }
        };

        // Call the logTest function
        logTest(test);

        // Verify that console.log was called with the correct arguments
        expect(mockConsoleLog).toHaveBeenCalledWith("=====================================");
        expect(mockConsoleLog).toHaveBeenCalledWith("Running test: ", test.name);
        expect(mockConsoleLog).toHaveBeenCalledWith("Description: ", test.description);
        expect(mockConsoleLog).toHaveBeenCalledWith("Path: ", test.path);
        expect(mockConsoleLog).toHaveBeenCalledWith("Method: ", test.method);
        expect(mockConsoleLog).toHaveBeenCalledWith("Params: ", test.params);
        expect(mockConsoleLog).toHaveBeenCalledWith("Expected: ", test.expected);

        // Check the total number of console.log calls (7 logs in total)
        expect(mockConsoleLog).toHaveBeenCalledTimes(7);
    });
});

describe('buildOptions', () => {
    test('should construct RequestOptions without query parameters', () => {
        const spec: OpenapiType = {
            servers: [{ url: 'https://api.example.com', description: 'description' }],
        };

        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [],
            },
            expected: {
                status: 200
            }
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/users',
            method: 'GET',
        };

        const result = buildOptions(spec, test);
        expect(result).toEqual(expected);
    });

    test('should construct RequestOptions with query parameters', () => {
        const spec: OpenapiType = {
            servers: [{ url: 'https://api.example.com', description: 'description' }],
        };

        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [
                    { name: 'name', value: 'john' },
                    { name: 'age', value: '25' },
                ],
            },
            expected: {
                status: 200
            }
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/users?name=john&age=25',
            method: 'GET',
        };

        const result = buildOptions(spec, test);
        expect(result).toEqual(expected);
    });

    test('should construct RequestOptions when server URL has a suffix', () => {
        const spec: OpenapiType = {
            servers: [{ url: 'https://api.example.com/v1', description: 'description' }],
        };

        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [],
            },
            expected: {
                status: 200
            }
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/v1/users',
            method: 'GET',
        };

        const result = buildOptions(spec, test);
        expect(result).toEqual(expected);
    });

    test('should construct RequestOptions with query parameters and a server URL suffix', () => {
        const spec: OpenapiType = {
            servers: [{ url: 'https://api.example.com/v1', description: 'description' }],
        };

        const test: TestCaseType = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [
                    { name: 'role', value: 'admin' },
                ],
            },
            expected: {
                status: 200
            }
        };

        const expected: RequestOptions = {
            host: 'api.example.com',
            port: 443,
            path: '/v1/users?role=admin',
            method: 'GET',
        };

        const result = buildOptions(spec, test);
        expect(result).toEqual(expected);
    });
});

describe('sendRequest', () => {
    let requestOptions: RequestOptions;
    let testCase: TestCaseType;
    let mockResponse: any;

    beforeEach(() => {
        // Define sample requestOptions and testCase for testing
        requestOptions = {
            hostname: 'example.com',
            path: '/api/test',
            method: 'GET',
        };

        testCase = {
            path: '/users',
            method: 'GET',
            name: 'name',
            description: 'description',
            params: {
                query: [
                    { name: 'role', value: 'admin' },
                ],
            },
            expected: {
                status: 200
            }
        };

        // Mocking the response object
        mockResponse = {
            statusCode: 200,
            on: jest.fn((event: string, callback: () => void) => {
                if (event === 'end') {
                    callback();
                }
            }),
        };

        // Mocking https.request
        (https.request as jest.Mock).mockImplementation((options, callback) => {
            callback(mockResponse);
            return {
                end: jest.fn(),
            };
        });

        jest.spyOn(process, 'exit').mockImplementation((code) => {
            throw new Error(`process.exit: ${code}`);
        });
    });

    afterEach(() => {
        jest.restoreAllMocks();
    });

    test('should log "Status code match" if status matches', () => {
        const consoleLogSpy = jest.spyOn(console, 'log');

        sendRequest(requestOptions, testCase);

        expect(consoleLogSpy).toHaveBeenCalledWith("Status code match: ", 200);
    });

    test('should log error and exit if status does not match', () => {
        mockResponse.statusCode = 404;
        const consoleErrorSpy = jest.spyOn(console, 'error');

        expect(() => sendRequest(requestOptions, testCase)).toThrow("process.exit: 1");

        expect(consoleErrorSpy).toHaveBeenCalledWith(
            "Status code does not match. Expected: ",
            200,
            " Got: ",
            404
        );
    });
});
