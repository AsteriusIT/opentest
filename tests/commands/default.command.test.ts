import { EventEmitter } from 'events';
import { IncomingMessage } from 'http';
import { RequestOptions } from 'https';
import { OpenAPIV3 } from 'openapi-types';
import { TestRunner } from '../../src/commands/default.command';
import { ApiRequestHandler } from "../../src/handlers/apiRequest.handler";
import { TestCaseType } from '../../src/types/testCase.type';
import { TestFileType } from '../../src/types/testFile.type';
import { ILogger } from '../../src/utils/logger.util';
import { SchemaValidator } from "../../src/utils/schema.util";

jest.mock('../../src/handlers/apiRequest.handler');
jest.mock('../../src/utils/logger.util');
jest.mock('../../src/utils/schema.util');

describe('TestRunner', () => {
    let testRunner: TestRunner;
    let mockApiHandler: jest.Mocked<ApiRequestHandler>;
    let mockLogger: jest.Mocked<ILogger>;
    let mockSchemaValidator: jest.Mocked<SchemaValidator>;

    const mockSpec: OpenAPIV3.Document = {
        openapi: '3.0.0',
        info: { title: 'Test API', version: '1.0.0' },
        paths: {},
        servers: [{ url: 'https://api.example.com/v1' }]
    };
    const mockTests: TestFileType = {
        tests: [
            {
                name: 'Test 1',
                description: 'Test description',
                path: '/test',
                method: 'GET',
                params: { query: [] },
                expected: { status: 200 }
            }
        ]
    };

    beforeEach(() => {
        mockApiHandler = new ApiRequestHandler(mockSpec) as jest.Mocked<ApiRequestHandler>;
        mockLogger = {
            logTest: jest.fn(),
            logStatusCodeResult: jest.fn(),
            logBodyResult: jest.fn(),
            logBodyResultSuccess: jest.fn(),
            saveResponses: jest.fn()
        };
        mockSchemaValidator = new SchemaValidator(mockSpec) as jest.Mocked<SchemaValidator>;

        testRunner = new TestRunner(mockSpec, mockTests, mockLogger);
        (testRunner as any).apiHandler = mockApiHandler;
        (testRunner as any).schemaValidator = mockSchemaValidator;
    });

    describe('runTests', () => {
        it('should run all tests and return results', async () => {
            const mockIncomingMessage = new EventEmitter() as IncomingMessage;
            mockIncomingMessage.statusCode = 200;
            mockApiHandler.buildOptions.mockResolvedValue({} as RequestOptions);
            mockApiHandler.sendRequest.mockResolvedValue({ data: mockIncomingMessage, body: '{}' });

            const results = await testRunner.runTests();

            expect(results).toHaveLength(1);
            expect(results[0].passed).toBe(true);
            expect(results[0].errors).toHaveLength(1);
            expect(results[0].data).toEqual(mockTests.tests[0]);
        });
    });

    describe('runSingleTest', () => {
        it('should validate status code correctly', async () => {
            const mockIncomingMessage = new EventEmitter() as IncomingMessage;
            mockIncomingMessage.statusCode = 200;
            mockApiHandler.buildOptions.mockResolvedValue({} as RequestOptions);
            mockApiHandler.sendRequest.mockResolvedValue({ data: mockIncomingMessage, body: '{}' });

            const result = await (testRunner as any).runSingleTest(mockTests.tests[0]);

            expect(result.passed).toBe(true);
            expect(result.errors[0]).toEqual({
                test: 'status_code',
                valid: true,
                expected: 200,
                received: 200
            });
            expect(mockLogger.logTest).toHaveBeenCalled();
            expect(mockLogger.logStatusCodeResult).toHaveBeenCalledWith(200, 200);
        });

        it('should validate response body schema when ref is provided', async () => {
            const testWithBodySchema: TestCaseType = {
                ...mockTests.tests[0],
                expected: { status: 200, body: { ref: 'TestSchema' } }
            };
            const mockIncomingMessage = new EventEmitter() as IncomingMessage;
            mockIncomingMessage.statusCode = 200;
            mockApiHandler.buildOptions.mockResolvedValue({} as RequestOptions);
            mockApiHandler.sendRequest.mockResolvedValue({ data: mockIncomingMessage, body: '{"key": "value"}' });
            mockSchemaValidator.getSchemaFromOpenApi.mockReturnValue({ type: 'object' });
            mockSchemaValidator.validateJson.mockReturnValue({ success: true });

            const result = await (testRunner as any).runSingleTest(testWithBodySchema);

            expect(result.errors).toContainEqual({
                test: 'response_body_schema',
                valid: true,
                expected: { type: 'object' },
                received: '{"key": "value"}'
            });
            expect(mockLogger.logBodyResultSuccess).toHaveBeenCalledWith(true);
        });

        it('should validate response body value when value is provided', async () => {
            const testWithBodyValue: TestCaseType = {
                ...mockTests.tests[0],
                expected: { status: 200, body: { value: { key: 'value' } } }
            };
            const mockIncomingMessage = new EventEmitter() as IncomingMessage;
            mockIncomingMessage.statusCode = 200;
            mockApiHandler.buildOptions.mockResolvedValue({} as RequestOptions);
            mockApiHandler.sendRequest.mockResolvedValue({ data: mockIncomingMessage, body: '{"key": "value"}' });

            const result = await (testRunner as any).runSingleTest(testWithBodyValue);

            expect(result.errors).toContainEqual({
                test: 'response_body_value',
                valid: true,
                expected: { key: 'value' },
                received: '{"key": "value"}'
            });
            expect(mockLogger.logBodyResult).toHaveBeenCalledWith({ key: 'value' }, '{"key": "value"}');
            expect(mockLogger.logBodyResultSuccess).toHaveBeenCalledWith(false);
        });
    });
});