import {getOpenApiTestFile} from '../../src/utils/files.util';
import {validateSchema} from '../../src/utils/schema.util';
import {validateCommandFunc} from "../../src/commands/validate.command";

// Mock external dependencies
jest.mock('../../src/utils/files.util', () => ({
    getOpenApiTestFile: jest.fn(),
}));
jest.mock('../../src/utils/schema.util', () => ({
    validateSchema: jest.fn(),
}));

describe('validateCommandFunc', () => {
    let mockProcessExit: jest.SpyInstance;
    let mockConsoleError: jest.SpyInstance;

    beforeEach(() => {
        mockProcessExit = jest.spyOn(process, 'exit').mockImplementation();
        mockConsoleError = jest.spyOn(console, 'error').mockImplementation(() => {
        });
    });

    afterEach(() => {
        jest.clearAllMocks();  // Clear mocks between tests
    });

    test('should not throw error for valid input', () => {
        // Mock a valid OpenAPI test file
        const validTestFile = {
            tests: [{name: 'Test 1', path: '/api/v1/login', method: 'POST', expected: {status: 200}}]
        };
        // Mock getOpenApiTestFile to return a valid test file
        (getOpenApiTestFile as jest.Mock).mockReturnValue(validTestFile);

        // Mock validateSchema to return success
        (validateSchema as jest.Mock).mockReturnValue({success: true});

        // Call the function
        validateCommandFunc('validFile.json');

        // No process exit and no error log should be called
        expect(mockConsoleError).not.toHaveBeenCalled();
        expect(mockProcessExit).not.toHaveBeenCalled();
    });

    test('should log error and exit when validation fails', () => {
        // Mock a valid OpenAPI test file
        const validTestFile = {
            tests: [{name: 'Test 1', path: '/api/v1/login', method: 'POST', expected: {status: 200}}]
        };
        // Mock getOpenApiTestFile to return the test file
        (getOpenApiTestFile as jest.Mock).mockReturnValue(validTestFile);

        // Mock validateSchema to return failure
        const errorObject = [{message: 'Invalid schema', instancePath: '/tests/0'}];
        (validateSchema as jest.Mock).mockReturnValue({success: false, errors: errorObject});

        // Call the function
        validateCommandFunc('invalidFile.json');

        // Check that the error was logged and process.exit was called
        expect(mockConsoleError).toHaveBeenCalledWith('Validation failed: ', errorObject);
        expect(mockProcessExit).toHaveBeenCalledWith(1);
    });

    test('should throw error if getOpenApiTestFile throws', () => {
        // Mock getOpenApiTestFile to throw an error
        (getOpenApiTestFile as jest.Mock).mockImplementation(() => {
            throw new Error('File not found');
        });

        // Expect the function to throw the error
        expect(() => validateCommandFunc('nonExistentFile.json')).toThrow('File not found');

        // process.exit should not be called since it should throw
        expect(mockProcessExit).not.toHaveBeenCalled();
    });
});

