import {buildOptions, defaultCommandHandler, logTest, sendRequest} from '../../src/commands/default.command'; // Adjust the import path
import {getOpenApiFile, getOpenApiTestFile} from '../../src/utils/files.util';
import {validateCommandFunc} from '../../src/commands/validate.command';
import {OpenapiType} from '../../src/types/openapi.type';
import {TestFileType} from '../../src/types/testFile.type';
import {TestCaseType} from '../../src/types/testCase.type';
import {RequestOptions} from 'https';

jest.mock('../../src/utils/files.util');
jest.mock('../../src/commands/validate.command');
jest.mock('../../src/commands/default.command', () => ({
    ...jest.requireActual('../../src/commands/default.command'),  // Only mock `sendRequest`, `buildOptions`, and `logTest`
    sendRequest: jest.fn(),
    buildOptions: jest.fn(),
    logTest: jest.fn(),
}));

describe('defaultCommandHandler', () => {
    let mockSpec: OpenapiType;
    let mockTestFile: TestFileType;
    let mockRequestOptions: RequestOptions;

    beforeEach(() => {
        mockSpec = {
            servers: [{ url: 'https://example.com' }],
        } as OpenapiType;

        mockTestFile = {
            tests: [
                {
                    name: 'Test 1',
                    description: 'Test description',
                    path: '/api/test',
                    method: 'GET',
                    params: {
                        query: [],
                    },
                    expected: {
                        status: 200,
                    },
                } as TestCaseType,
            ],
        };

        mockRequestOptions = {
            hostname: 'example.com',
            path: '/api/test',
            method: 'GET',
        } as RequestOptions;

        (getOpenApiFile as jest.Mock).mockReturnValue(mockSpec);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(mockTestFile);
        (buildOptions as jest.Mock).mockReturnValue(mockRequestOptions);
        (sendRequest as jest.Mock).mockImplementation((options, test) => {
            // Simulate successful response by invoking the callback
            process.nextTick(() => {
                if (test.expected.status === 200) {
                    // Simulate successful HTTP response
                    return {
                        statusCode: 200,
                    };
                } else {
                    // Simulate failure
                    console.error("Status code does not match.");
                    process.exit(1);
                }
            });
        });
        (logTest as jest.Mock).mockImplementation(() => {});
        (validateCommandFunc as jest.Mock).mockImplementation(() => {});

        // Mock process.exit to prevent it from stopping the test
        jest.spyOn(process, 'exit').mockImplementation((code) => {
            throw new Error(`process.exit: ${code}`);
        });

        // Mock console logs to prevent unnecessary outputs
        jest.spyOn(console, 'log').mockImplementation(() => {});
        jest.spyOn(console, 'error').mockImplementation(() => {});
    });

    afterEach(() => {
        jest.restoreAllMocks();
    });

    test('should run tests and send requests for each test case', () => {
        const options = { input: 'input.json', spec: 'spec.json' };
        defaultCommandHandler(options);

        // Assert that the helper functions were called as expected
        expect(getOpenApiFile).toHaveBeenCalledWith('spec.json');
        expect(getOpenApiTestFile).toHaveBeenCalledWith('input.json');
        expect(validateCommandFunc).toHaveBeenCalledWith('input.json');
        expect(logTest).toHaveBeenCalledWith(mockTestFile.tests[0]);
        expect(buildOptions).toHaveBeenCalledWith(mockSpec, mockTestFile.tests[0]);
        expect(sendRequest).toHaveBeenCalledWith(mockRequestOptions, mockTestFile.tests[0]);
    });

    test('should exit with code 1 if spec or tests are missing', () => {
        (getOpenApiFile as jest.Mock).mockReturnValue(null);

        const options = { input: 'input.json', spec: 'spec.json' };

        expect(() => defaultCommandHandler(options)).toThrow('process.exit: 1');

        (getOpenApiFile as jest.Mock).mockReturnValue(mockSpec);
        (getOpenApiTestFile as jest.Mock).mockReturnValue(null);

        expect(() => defaultCommandHandler(options)).toThrow('process.exit: 1');
    });

    test('should handle errors gracefully and log them', () => {
        const consoleErrorSpy = jest.spyOn(console, 'error');

        (getOpenApiFile as jest.Mock).mockImplementation(() => {
            throw new Error('Error reading file');
        });

        const options = { input: 'input.json', spec: 'spec.json' };

        expect(() => defaultCommandHandler(options)).toThrow('process.exit: 1');
        expect(consoleErrorSpy).toHaveBeenCalledWith('Error while reading or parsing file: Error reading file');
    });
});